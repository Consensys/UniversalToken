/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";

export type TradeRequestInputStruct = {
  holder1: string;
  holder2: string;
  executer: string;
  expirationDate: BigNumberish;
  tokenAddress1: string;
  tokenValue1: BigNumberish;
  tokenId1: BytesLike;
  tokenStandard1: BigNumberish;
  tokenAddress2: string;
  tokenValue2: BigNumberish;
  tokenId2: BytesLike;
  tokenStandard2: BigNumberish;
  tradeType1: BigNumberish;
  tradeType2: BigNumberish;
  settlementDate: BigNumberish;
};

export type TradeRequestInputStructOutput = [
  string,
  string,
  string,
  BigNumber,
  string,
  BigNumber,
  string,
  number,
  string,
  BigNumber,
  string,
  number,
  number,
  number,
  BigNumber
] & {
  holder1: string;
  holder2: string;
  executer: string;
  expirationDate: BigNumber;
  tokenAddress1: string;
  tokenValue1: BigNumber;
  tokenId1: string;
  tokenStandard1: number;
  tokenAddress2: string;
  tokenValue2: BigNumber;
  tokenId2: string;
  tokenStandard2: number;
  tradeType1: number;
  tradeType2: number;
  settlementDate: BigNumber;
};

export type UserTradeDataStruct = {
  tokenAddress: string;
  tokenValue: BigNumberish;
  tokenId: BytesLike;
  tokenStandard: BigNumberish;
  accepted: boolean;
  approved: boolean;
  tradeType: BigNumberish;
};

export type UserTradeDataStructOutput = [
  string,
  BigNumber,
  string,
  number,
  boolean,
  boolean,
  number
] & {
  tokenAddress: string;
  tokenValue: BigNumber;
  tokenId: string;
  tokenStandard: number;
  accepted: boolean;
  approved: boolean;
  tradeType: number;
};

export type TradeStruct = {
  holder1: string;
  holder2: string;
  executer: string;
  expirationDate: BigNumberish;
  settlementDate: BigNumberish;
  userTradeData1: UserTradeDataStruct;
  userTradeData2: UserTradeDataStruct;
  state: BigNumberish;
};

export type TradeStructOutput = [
  string,
  string,
  string,
  BigNumber,
  BigNumber,
  UserTradeDataStructOutput,
  UserTradeDataStructOutput,
  number
] & {
  holder1: string;
  holder2: string;
  executer: string;
  expirationDate: BigNumber;
  settlementDate: BigNumber;
  userTradeData1: UserTradeDataStructOutput;
  userTradeData2: UserTradeDataStructOutput;
  state: number;
};

export interface SwapsInterface extends utils.Interface {
  functions: {
    "canImplementInterfaceForAddress(bytes32,address)": FunctionFragment;
    "owner()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "canReceive(bytes,bytes32,address,address,address,uint256,bytes,bytes)": FunctionFragment;
    "tokensReceived(bytes,bytes32,address,address,address,uint256,bytes,bytes)": FunctionFragment;
    "requestTrade((address,address,address,uint256,address,uint256,bytes32,uint8,address,uint256,bytes32,uint8,uint8,uint8,uint256),bytes32)": FunctionFragment;
    "acceptTrade(uint256)": FunctionFragment;
    "acceptTradeWithPreimage(uint256,bytes32)": FunctionFragment;
    "getTradeAcceptanceStatus(uint256)": FunctionFragment;
    "approveTrade(uint256,bool)": FunctionFragment;
    "approveTradeWithPreimage(uint256,bool,bytes32)": FunctionFragment;
    "getTradeApprovalStatus(uint256)": FunctionFragment;
    "executeTrade(uint256)": FunctionFragment;
    "executeTradeWithPreimage(uint256,bytes32)": FunctionFragment;
    "forceTrade(uint256)": FunctionFragment;
    "forceTradeWithPreimage(uint256,bytes32)": FunctionFragment;
    "cancelTrade(uint256)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "tradeExecuters()": FunctionFragment;
    "setTradeExecuters(address[])": FunctionFragment;
    "tokenControllers(address)": FunctionFragment;
    "setTokenControllers(address,address[])": FunctionFragment;
    "priceOracles(address)": FunctionFragment;
    "setPriceOracles(address,address[])": FunctionFragment;
    "getPriceOwnership(address,address)": FunctionFragment;
    "setPriceOwnership(address,address,bool)": FunctionFragment;
    "variablePriceStartDate(address)": FunctionFragment;
    "setVariablePriceStartDate(address,uint256)": FunctionFragment;
    "getTokenPrice(address,address,bytes32,bytes32)": FunctionFragment;
    "setTokenPrice(address,address,bytes32,bytes32,uint256)": FunctionFragment;
    "getPrice(uint256)": FunctionFragment;
    "getTrade(uint256)": FunctionFragment;
    "getNbTrades()": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "canImplementInterfaceForAddress",
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "canReceive",
    values: [
      BytesLike,
      BytesLike,
      string,
      string,
      string,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "tokensReceived",
    values: [
      BytesLike,
      BytesLike,
      string,
      string,
      string,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "requestTrade",
    values: [TradeRequestInputStruct, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "acceptTrade",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "acceptTradeWithPreimage",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTradeAcceptanceStatus",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "approveTrade",
    values: [BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "approveTradeWithPreimage",
    values: [BigNumberish, boolean, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTradeApprovalStatus",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "executeTrade",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "executeTradeWithPreimage",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "forceTrade",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "forceTradeWithPreimage",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelTrade",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tradeExecuters",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setTradeExecuters",
    values: [string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenControllers",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setTokenControllers",
    values: [string, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "priceOracles",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setPriceOracles",
    values: [string, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getPriceOwnership",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "setPriceOwnership",
    values: [string, string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "variablePriceStartDate",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setVariablePriceStartDate",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenPrice",
    values: [string, string, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setTokenPrice",
    values: [string, string, BytesLike, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getPrice",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTrade",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getNbTrades",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "canImplementInterfaceForAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "canReceive", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "tokensReceived",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "requestTrade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "acceptTrade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "acceptTradeWithPreimage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTradeAcceptanceStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveTrade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveTradeWithPreimage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTradeApprovalStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeTrade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeTradeWithPreimage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "forceTrade", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "forceTradeWithPreimage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelTrade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tradeExecuters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTradeExecuters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenControllers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTokenControllers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "priceOracles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPriceOracles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPriceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPriceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "variablePriceStartDate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setVariablePriceStartDate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTokenPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getPrice", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getTrade", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getNbTrades",
    data: BytesLike
  ): Result;

  events: {
    "CreateNote(address,bytes32,bytes)": EventFragment;
    "DestroyNote(address,bytes32)": EventFragment;
    "ExecutedHold(address,bytes32,bytes32,address)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "Transfer(address,address,uint256)": EventFragment;
    "TransferByPartition(bytes32,address,address,address,uint256,bytes,bytes)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "CreateNote"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DestroyNote"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExecutedHold"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransferByPartition"): EventFragment;
}

export type CreateNoteEvent = TypedEvent<
  [string, string, string],
  { owner: string; noteHash: string; metadata: string }
>;

export type CreateNoteEventFilter = TypedEventFilter<CreateNoteEvent>;

export type DestroyNoteEvent = TypedEvent<
  [string, string],
  { owner: string; noteHash: string }
>;

export type DestroyNoteEventFilter = TypedEventFilter<DestroyNoteEvent>;

export type ExecutedHoldEvent = TypedEvent<
  [string, string, string, string],
  { token: string; holdId: string; lockPreimage: string; recipient: string }
>;

export type ExecutedHoldEventFilter = TypedEventFilter<ExecutedHoldEvent>;

export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  { previousOwner: string; newOwner: string }
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export type TransferEvent = TypedEvent<
  [string, string, BigNumber],
  { from: string; to: string; tokens: BigNumber }
>;

export type TransferEventFilter = TypedEventFilter<TransferEvent>;

export type TransferByPartitionEvent = TypedEvent<
  [string, string, string, string, BigNumber, string, string],
  {
    fromPartition: string;
    operator: string;
    from: string;
    to: string;
    value: BigNumber;
    data: string;
    operatorData: string;
  }
>;

export type TransferByPartitionEventFilter =
  TypedEventFilter<TransferByPartitionEvent>;

export interface Swaps extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: SwapsInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Indicate whether or not the DVP contract can receive the tokens or not. [USED FOR ERC1400 TOKENS ONLY]
     * [ERC1400TokensRecipient INTERFACE (1/2)]
     * @param data Information attached to the token transfer.
     * @param operatorData Information attached to the DVP transfer, by the operator.
     */
    canReceive(
      arg0: BytesLike,
      arg1: BytesLike,
      arg2: string,
      arg3: string,
      arg4: string,
      arg5: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Hook function executed when tokens are sent to the DVP contract. [USED FOR ERC1400 TOKENS ONLY]
     * [ERC1400TokensRecipient INTERFACE (2/2)]
     * @param data Information attached to the token transfer.
     * @param from Token holder.
     * @param operatorData Information attached to the DVP transfer, by the operator.
     * @param partition Name of the partition.
     * @param to Token recipient.
     * @param value Number of tokens to transfer.
     */
    tokensReceived(
      arg0: BytesLike,
      partition: BytesLike,
      arg2: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    requestTrade(
      inputData: TradeRequestInputStruct,
      preimage: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Accept a given trade (+ potentially escrow tokens).
     * @param index Index of the trade to be accepted.
     */
    acceptTrade(
      index: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Accept a given trade (+ potentially escrow tokens).
     * @param index Index of the trade to be accepted.
     */
    acceptTradeWithPreimage(
      index: BigNumberish,
      preimage: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Verify if a trade has been accepted by the token holders. The trade needs to be accepted by both parties (token holders) before it gets executed.
     * @param index Index of the trade to be accepted.
     */
    getTradeAcceptanceStatus(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    approveTrade(
      index: BigNumberish,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Approve a trade (if the tokens involved in the trade are controlled) This function can only be called by a token controller of one of the tokens involved in the trade. Indeed, when a token smart contract is controlled by an owner, the owner can decide to open the secondary market by:  - Allowlisting the DVP smart contract  - Setting "token controllers" in the DVP smart contract, in order to approve all the trades made with his token
     * @param approved 'true' if trade is approved, 'false' if not.
     * @param index Index of the trade to be executed.
     */
    approveTradeWithPreimage(
      index: BigNumberish,
      approved: boolean,
      preimage: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Verify if a trade has been approved by the token controllers. In case a given token has token controllers, those need to validate the trade before it gets executed.
     * @param index Index of the trade to be approved.
     */
    getTradeApprovalStatus(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    executeTrade(
      index: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Execute a trade in the DVP contract if possible (e.g. if tokens have been esccrowed, in case it is required). This function can only be called by the executer specified at trade creation. If no executer is specified, the trade can be launched by anyone.
     * @param index Index of the trade to be executed.
     */
    executeTradeWithPreimage(
      index: BigNumberish,
      preimage: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    forceTrade(
      index: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Force a trade execution in the DVP contract by transferring tokens back to their target recipients.
     * @param index Index of the trade to be forced.
     */
    forceTradeWithPreimage(
      index: BigNumberish,
      preimage: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Cancel a trade execution in the DVP contract by transferring tokens back to their initial owners.
     * @param index Index of the trade to be cancelled.
     */
    cancelTrade(
      index: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Renounce ownership of the contract.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get the list of trade executers as defined by the DVP contract.
     */
    tradeExecuters(overrides?: CallOverrides): Promise<[string[]]>;

    /**
     * Set list of trade executers for the DVP contract.
     * @param operators Trade executers addresses.
     */
    setTradeExecuters(
      operators: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get the list of token controllers for a given token.
     * @param tokenAddress Token address.
     */
    tokenControllers(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Set list of token controllers for a given token.
     * @param operators Operators addresses.
     * @param tokenAddress Token address.
     */
    setTokenControllers(
      tokenAddress: string,
      operators: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get the list of price oracles for a given token.
     * @param tokenAddress Token address.
     */
    priceOracles(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Set list of price oracles for a given token.
     * @param oracles Oracles addresses.
     * @param tokenAddress Token address.
     */
    setPriceOracles(
      tokenAddress: string,
      oracles: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get price of the token.
     * @param tokenAddress1 Address of the token to be priced.
     * @param tokenAddress2 Address of the token to pay for token1.
     */
    getPriceOwnership(
      tokenAddress1: string,
      tokenAddress2: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Take ownership for setting the price of a token.
     * @param tokenAddress1 Address of the token to be priced.
     * @param tokenAddress2 Address of the token to pay for token1.
     */
    setPriceOwnership(
      tokenAddress1: string,
      tokenAddress2: string,
      priceOwnership: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get date after which the token price can potentially be set by an oracle (0 if price can not be set by an oracle).
     * @param tokenAddress Token address.
     */
    variablePriceStartDate(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Set date after which the token price can potentially be set by an oracle (0 if price can not be set by an oracle).
     * @param startDate Date after which token price can potentially be set by an oracle (0 if price can not be set by an oracle).
     * @param tokenAddress Token address.
     */
    setVariablePriceStartDate(
      tokenAddress: string,
      startDate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get price of the token.
     * @param tokenAddress1 Address of the token to be priced.
     * @param tokenAddress2 Address of the token to pay for token1.
     * @param tokenId1 ID/partition of the token2 (set to 0 bytes32 if price is set for all IDs/partitions).
     */
    getTokenPrice(
      tokenAddress1: string,
      tokenAddress2: string,
      tokenId1: BytesLike,
      tokenId2: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Set price of a token.
     * @param newPrice New price of the token.
     * @param tokenAddress1 Address of the token to be priced.
     * @param tokenAddress2 Address of the token to pay for token1.
     * @param tokenId1 ID/partition of the token1 (set to 0 bytes32 if price is set for all IDs/partitions).
     * @param tokenId2 ID/partition of the token2 (set to 0 bytes32 if price is set for all IDs/partitions).
     */
    setTokenPrice(
      tokenAddress1: string,
      tokenAddress2: string,
      tokenId1: BytesLike,
      tokenId2: BytesLike,
      newPrice: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get amount of token2 to pay to acquire the token1.
     * @param index Index of the DVP request.
     */
    getPrice(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Get the trade.
     * @param index Index of the trade.
     */
    getTrade(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[TradeStructOutput]>;

    /**
     * Get the total number of requests in the DVP contract.
     */
    getNbTrades(overrides?: CallOverrides): Promise<[BigNumber]>;
  };

  canImplementInterfaceForAddress(
    interfaceHash: BytesLike,
    arg1: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Returns the address of the current owner.
   */
  owner(overrides?: CallOverrides): Promise<string>;

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
   */
  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Indicate whether or not the DVP contract can receive the tokens or not. [USED FOR ERC1400 TOKENS ONLY]
   * [ERC1400TokensRecipient INTERFACE (1/2)]
   * @param data Information attached to the token transfer.
   * @param operatorData Information attached to the DVP transfer, by the operator.
   */
  canReceive(
    arg0: BytesLike,
    arg1: BytesLike,
    arg2: string,
    arg3: string,
    arg4: string,
    arg5: BigNumberish,
    data: BytesLike,
    operatorData: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Hook function executed when tokens are sent to the DVP contract. [USED FOR ERC1400 TOKENS ONLY]
   * [ERC1400TokensRecipient INTERFACE (2/2)]
   * @param data Information attached to the token transfer.
   * @param from Token holder.
   * @param operatorData Information attached to the DVP transfer, by the operator.
   * @param partition Name of the partition.
   * @param to Token recipient.
   * @param value Number of tokens to transfer.
   */
  tokensReceived(
    arg0: BytesLike,
    partition: BytesLike,
    arg2: string,
    from: string,
    to: string,
    value: BigNumberish,
    data: BytesLike,
    operatorData: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  requestTrade(
    inputData: TradeRequestInputStruct,
    preimage: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Accept a given trade (+ potentially escrow tokens).
   * @param index Index of the trade to be accepted.
   */
  acceptTrade(
    index: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Accept a given trade (+ potentially escrow tokens).
   * @param index Index of the trade to be accepted.
   */
  acceptTradeWithPreimage(
    index: BigNumberish,
    preimage: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Verify if a trade has been accepted by the token holders. The trade needs to be accepted by both parties (token holders) before it gets executed.
   * @param index Index of the trade to be accepted.
   */
  getTradeAcceptanceStatus(
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  approveTrade(
    index: BigNumberish,
    approved: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Approve a trade (if the tokens involved in the trade are controlled) This function can only be called by a token controller of one of the tokens involved in the trade. Indeed, when a token smart contract is controlled by an owner, the owner can decide to open the secondary market by:  - Allowlisting the DVP smart contract  - Setting "token controllers" in the DVP smart contract, in order to approve all the trades made with his token
   * @param approved 'true' if trade is approved, 'false' if not.
   * @param index Index of the trade to be executed.
   */
  approveTradeWithPreimage(
    index: BigNumberish,
    approved: boolean,
    preimage: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Verify if a trade has been approved by the token controllers. In case a given token has token controllers, those need to validate the trade before it gets executed.
   * @param index Index of the trade to be approved.
   */
  getTradeApprovalStatus(
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  executeTrade(
    index: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Execute a trade in the DVP contract if possible (e.g. if tokens have been esccrowed, in case it is required). This function can only be called by the executer specified at trade creation. If no executer is specified, the trade can be launched by anyone.
   * @param index Index of the trade to be executed.
   */
  executeTradeWithPreimage(
    index: BigNumberish,
    preimage: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  forceTrade(
    index: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Force a trade execution in the DVP contract by transferring tokens back to their target recipients.
   * @param index Index of the trade to be forced.
   */
  forceTradeWithPreimage(
    index: BigNumberish,
    preimage: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Cancel a trade execution in the DVP contract by transferring tokens back to their initial owners.
   * @param index Index of the trade to be cancelled.
   */
  cancelTrade(
    index: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Renounce ownership of the contract.
   */
  renounceOwnership(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get the list of trade executers as defined by the DVP contract.
   */
  tradeExecuters(overrides?: CallOverrides): Promise<string[]>;

  /**
   * Set list of trade executers for the DVP contract.
   * @param operators Trade executers addresses.
   */
  setTradeExecuters(
    operators: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get the list of token controllers for a given token.
   * @param tokenAddress Token address.
   */
  tokenControllers(
    tokenAddress: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Set list of token controllers for a given token.
   * @param operators Operators addresses.
   * @param tokenAddress Token address.
   */
  setTokenControllers(
    tokenAddress: string,
    operators: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get the list of price oracles for a given token.
   * @param tokenAddress Token address.
   */
  priceOracles(
    tokenAddress: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Set list of price oracles for a given token.
   * @param oracles Oracles addresses.
   * @param tokenAddress Token address.
   */
  setPriceOracles(
    tokenAddress: string,
    oracles: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get price of the token.
   * @param tokenAddress1 Address of the token to be priced.
   * @param tokenAddress2 Address of the token to pay for token1.
   */
  getPriceOwnership(
    tokenAddress1: string,
    tokenAddress2: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Take ownership for setting the price of a token.
   * @param tokenAddress1 Address of the token to be priced.
   * @param tokenAddress2 Address of the token to pay for token1.
   */
  setPriceOwnership(
    tokenAddress1: string,
    tokenAddress2: string,
    priceOwnership: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get date after which the token price can potentially be set by an oracle (0 if price can not be set by an oracle).
   * @param tokenAddress Token address.
   */
  variablePriceStartDate(
    tokenAddress: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Set date after which the token price can potentially be set by an oracle (0 if price can not be set by an oracle).
   * @param startDate Date after which token price can potentially be set by an oracle (0 if price can not be set by an oracle).
   * @param tokenAddress Token address.
   */
  setVariablePriceStartDate(
    tokenAddress: string,
    startDate: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get price of the token.
   * @param tokenAddress1 Address of the token to be priced.
   * @param tokenAddress2 Address of the token to pay for token1.
   * @param tokenId1 ID/partition of the token2 (set to 0 bytes32 if price is set for all IDs/partitions).
   */
  getTokenPrice(
    tokenAddress1: string,
    tokenAddress2: string,
    tokenId1: BytesLike,
    tokenId2: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Set price of a token.
   * @param newPrice New price of the token.
   * @param tokenAddress1 Address of the token to be priced.
   * @param tokenAddress2 Address of the token to pay for token1.
   * @param tokenId1 ID/partition of the token1 (set to 0 bytes32 if price is set for all IDs/partitions).
   * @param tokenId2 ID/partition of the token2 (set to 0 bytes32 if price is set for all IDs/partitions).
   */
  setTokenPrice(
    tokenAddress1: string,
    tokenAddress2: string,
    tokenId1: BytesLike,
    tokenId2: BytesLike,
    newPrice: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get amount of token2 to pay to acquire the token1.
   * @param index Index of the DVP request.
   */
  getPrice(index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the trade.
   * @param index Index of the trade.
   */
  getTrade(
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<TradeStructOutput>;

  /**
   * Get the total number of requests in the DVP contract.
   */
  getNbTrades(overrides?: CallOverrides): Promise<BigNumber>;

  callStatic: {
    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<string>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Indicate whether or not the DVP contract can receive the tokens or not. [USED FOR ERC1400 TOKENS ONLY]
     * [ERC1400TokensRecipient INTERFACE (1/2)]
     * @param data Information attached to the token transfer.
     * @param operatorData Information attached to the DVP transfer, by the operator.
     */
    canReceive(
      arg0: BytesLike,
      arg1: BytesLike,
      arg2: string,
      arg3: string,
      arg4: string,
      arg5: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Hook function executed when tokens are sent to the DVP contract. [USED FOR ERC1400 TOKENS ONLY]
     * [ERC1400TokensRecipient INTERFACE (2/2)]
     * @param data Information attached to the token transfer.
     * @param from Token holder.
     * @param operatorData Information attached to the DVP transfer, by the operator.
     * @param partition Name of the partition.
     * @param to Token recipient.
     * @param value Number of tokens to transfer.
     */
    tokensReceived(
      arg0: BytesLike,
      partition: BytesLike,
      arg2: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    requestTrade(
      inputData: TradeRequestInputStruct,
      preimage: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Accept a given trade (+ potentially escrow tokens).
     * @param index Index of the trade to be accepted.
     */
    acceptTrade(index: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * Accept a given trade (+ potentially escrow tokens).
     * @param index Index of the trade to be accepted.
     */
    acceptTradeWithPreimage(
      index: BigNumberish,
      preimage: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Verify if a trade has been accepted by the token holders. The trade needs to be accepted by both parties (token holders) before it gets executed.
     * @param index Index of the trade to be accepted.
     */
    getTradeAcceptanceStatus(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    approveTrade(
      index: BigNumberish,
      approved: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Approve a trade (if the tokens involved in the trade are controlled) This function can only be called by a token controller of one of the tokens involved in the trade. Indeed, when a token smart contract is controlled by an owner, the owner can decide to open the secondary market by:  - Allowlisting the DVP smart contract  - Setting "token controllers" in the DVP smart contract, in order to approve all the trades made with his token
     * @param approved 'true' if trade is approved, 'false' if not.
     * @param index Index of the trade to be executed.
     */
    approveTradeWithPreimage(
      index: BigNumberish,
      approved: boolean,
      preimage: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Verify if a trade has been approved by the token controllers. In case a given token has token controllers, those need to validate the trade before it gets executed.
     * @param index Index of the trade to be approved.
     */
    getTradeApprovalStatus(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    executeTrade(index: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * Execute a trade in the DVP contract if possible (e.g. if tokens have been esccrowed, in case it is required). This function can only be called by the executer specified at trade creation. If no executer is specified, the trade can be launched by anyone.
     * @param index Index of the trade to be executed.
     */
    executeTradeWithPreimage(
      index: BigNumberish,
      preimage: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    forceTrade(index: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * Force a trade execution in the DVP contract by transferring tokens back to their target recipients.
     * @param index Index of the trade to be forced.
     */
    forceTradeWithPreimage(
      index: BigNumberish,
      preimage: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Cancel a trade execution in the DVP contract by transferring tokens back to their initial owners.
     * @param index Index of the trade to be cancelled.
     */
    cancelTrade(index: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * Renounce ownership of the contract.
     */
    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    /**
     * Get the list of trade executers as defined by the DVP contract.
     */
    tradeExecuters(overrides?: CallOverrides): Promise<string[]>;

    /**
     * Set list of trade executers for the DVP contract.
     * @param operators Trade executers addresses.
     */
    setTradeExecuters(
      operators: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get the list of token controllers for a given token.
     * @param tokenAddress Token address.
     */
    tokenControllers(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Set list of token controllers for a given token.
     * @param operators Operators addresses.
     * @param tokenAddress Token address.
     */
    setTokenControllers(
      tokenAddress: string,
      operators: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get the list of price oracles for a given token.
     * @param tokenAddress Token address.
     */
    priceOracles(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Set list of price oracles for a given token.
     * @param oracles Oracles addresses.
     * @param tokenAddress Token address.
     */
    setPriceOracles(
      tokenAddress: string,
      oracles: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get price of the token.
     * @param tokenAddress1 Address of the token to be priced.
     * @param tokenAddress2 Address of the token to pay for token1.
     */
    getPriceOwnership(
      tokenAddress1: string,
      tokenAddress2: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Take ownership for setting the price of a token.
     * @param tokenAddress1 Address of the token to be priced.
     * @param tokenAddress2 Address of the token to pay for token1.
     */
    setPriceOwnership(
      tokenAddress1: string,
      tokenAddress2: string,
      priceOwnership: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get date after which the token price can potentially be set by an oracle (0 if price can not be set by an oracle).
     * @param tokenAddress Token address.
     */
    variablePriceStartDate(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Set date after which the token price can potentially be set by an oracle (0 if price can not be set by an oracle).
     * @param startDate Date after which token price can potentially be set by an oracle (0 if price can not be set by an oracle).
     * @param tokenAddress Token address.
     */
    setVariablePriceStartDate(
      tokenAddress: string,
      startDate: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get price of the token.
     * @param tokenAddress1 Address of the token to be priced.
     * @param tokenAddress2 Address of the token to pay for token1.
     * @param tokenId1 ID/partition of the token2 (set to 0 bytes32 if price is set for all IDs/partitions).
     */
    getTokenPrice(
      tokenAddress1: string,
      tokenAddress2: string,
      tokenId1: BytesLike,
      tokenId2: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Set price of a token.
     * @param newPrice New price of the token.
     * @param tokenAddress1 Address of the token to be priced.
     * @param tokenAddress2 Address of the token to pay for token1.
     * @param tokenId1 ID/partition of the token1 (set to 0 bytes32 if price is set for all IDs/partitions).
     * @param tokenId2 ID/partition of the token2 (set to 0 bytes32 if price is set for all IDs/partitions).
     */
    setTokenPrice(
      tokenAddress1: string,
      tokenAddress2: string,
      tokenId1: BytesLike,
      tokenId2: BytesLike,
      newPrice: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get amount of token2 to pay to acquire the token1.
     * @param index Index of the DVP request.
     */
    getPrice(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the trade.
     * @param index Index of the trade.
     */
    getTrade(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<TradeStructOutput>;

    /**
     * Get the total number of requests in the DVP contract.
     */
    getNbTrades(overrides?: CallOverrides): Promise<BigNumber>;
  };

  filters: {
    "CreateNote(address,bytes32,bytes)"(
      owner?: string | null,
      noteHash?: BytesLike | null,
      metadata?: null
    ): CreateNoteEventFilter;
    CreateNote(
      owner?: string | null,
      noteHash?: BytesLike | null,
      metadata?: null
    ): CreateNoteEventFilter;

    "DestroyNote(address,bytes32)"(
      owner?: string | null,
      noteHash?: BytesLike | null
    ): DestroyNoteEventFilter;
    DestroyNote(
      owner?: string | null,
      noteHash?: BytesLike | null
    ): DestroyNoteEventFilter;

    "ExecutedHold(address,bytes32,bytes32,address)"(
      token?: string | null,
      holdId?: BytesLike | null,
      lockPreimage?: null,
      recipient?: null
    ): ExecutedHoldEventFilter;
    ExecutedHold(
      token?: string | null,
      holdId?: BytesLike | null,
      lockPreimage?: null,
      recipient?: null
    ): ExecutedHoldEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;

    "Transfer(address,address,uint256)"(
      from?: string | null,
      to?: string | null,
      tokens?: null
    ): TransferEventFilter;
    Transfer(
      from?: string | null,
      to?: string | null,
      tokens?: null
    ): TransferEventFilter;

    "TransferByPartition(bytes32,address,address,address,uint256,bytes,bytes)"(
      fromPartition?: BytesLike | null,
      operator?: null,
      from?: string | null,
      to?: string | null,
      value?: null,
      data?: null,
      operatorData?: null
    ): TransferByPartitionEventFilter;
    TransferByPartition(
      fromPartition?: BytesLike | null,
      operator?: null,
      from?: string | null,
      to?: string | null,
      value?: null,
      data?: null,
      operatorData?: null
    ): TransferByPartitionEventFilter;
  };

  estimateGas: {
    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Indicate whether or not the DVP contract can receive the tokens or not. [USED FOR ERC1400 TOKENS ONLY]
     * [ERC1400TokensRecipient INTERFACE (1/2)]
     * @param data Information attached to the token transfer.
     * @param operatorData Information attached to the DVP transfer, by the operator.
     */
    canReceive(
      arg0: BytesLike,
      arg1: BytesLike,
      arg2: string,
      arg3: string,
      arg4: string,
      arg5: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Hook function executed when tokens are sent to the DVP contract. [USED FOR ERC1400 TOKENS ONLY]
     * [ERC1400TokensRecipient INTERFACE (2/2)]
     * @param data Information attached to the token transfer.
     * @param from Token holder.
     * @param operatorData Information attached to the DVP transfer, by the operator.
     * @param partition Name of the partition.
     * @param to Token recipient.
     * @param value Number of tokens to transfer.
     */
    tokensReceived(
      arg0: BytesLike,
      partition: BytesLike,
      arg2: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    requestTrade(
      inputData: TradeRequestInputStruct,
      preimage: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Accept a given trade (+ potentially escrow tokens).
     * @param index Index of the trade to be accepted.
     */
    acceptTrade(
      index: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Accept a given trade (+ potentially escrow tokens).
     * @param index Index of the trade to be accepted.
     */
    acceptTradeWithPreimage(
      index: BigNumberish,
      preimage: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Verify if a trade has been accepted by the token holders. The trade needs to be accepted by both parties (token holders) before it gets executed.
     * @param index Index of the trade to be accepted.
     */
    getTradeAcceptanceStatus(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    approveTrade(
      index: BigNumberish,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Approve a trade (if the tokens involved in the trade are controlled) This function can only be called by a token controller of one of the tokens involved in the trade. Indeed, when a token smart contract is controlled by an owner, the owner can decide to open the secondary market by:  - Allowlisting the DVP smart contract  - Setting "token controllers" in the DVP smart contract, in order to approve all the trades made with his token
     * @param approved 'true' if trade is approved, 'false' if not.
     * @param index Index of the trade to be executed.
     */
    approveTradeWithPreimage(
      index: BigNumberish,
      approved: boolean,
      preimage: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Verify if a trade has been approved by the token controllers. In case a given token has token controllers, those need to validate the trade before it gets executed.
     * @param index Index of the trade to be approved.
     */
    getTradeApprovalStatus(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    executeTrade(
      index: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Execute a trade in the DVP contract if possible (e.g. if tokens have been esccrowed, in case it is required). This function can only be called by the executer specified at trade creation. If no executer is specified, the trade can be launched by anyone.
     * @param index Index of the trade to be executed.
     */
    executeTradeWithPreimage(
      index: BigNumberish,
      preimage: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    forceTrade(
      index: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Force a trade execution in the DVP contract by transferring tokens back to their target recipients.
     * @param index Index of the trade to be forced.
     */
    forceTradeWithPreimage(
      index: BigNumberish,
      preimage: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Cancel a trade execution in the DVP contract by transferring tokens back to their initial owners.
     * @param index Index of the trade to be cancelled.
     */
    cancelTrade(
      index: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Renounce ownership of the contract.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get the list of trade executers as defined by the DVP contract.
     */
    tradeExecuters(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Set list of trade executers for the DVP contract.
     * @param operators Trade executers addresses.
     */
    setTradeExecuters(
      operators: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get the list of token controllers for a given token.
     * @param tokenAddress Token address.
     */
    tokenControllers(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Set list of token controllers for a given token.
     * @param operators Operators addresses.
     * @param tokenAddress Token address.
     */
    setTokenControllers(
      tokenAddress: string,
      operators: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get the list of price oracles for a given token.
     * @param tokenAddress Token address.
     */
    priceOracles(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Set list of price oracles for a given token.
     * @param oracles Oracles addresses.
     * @param tokenAddress Token address.
     */
    setPriceOracles(
      tokenAddress: string,
      oracles: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get price of the token.
     * @param tokenAddress1 Address of the token to be priced.
     * @param tokenAddress2 Address of the token to pay for token1.
     */
    getPriceOwnership(
      tokenAddress1: string,
      tokenAddress2: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Take ownership for setting the price of a token.
     * @param tokenAddress1 Address of the token to be priced.
     * @param tokenAddress2 Address of the token to pay for token1.
     */
    setPriceOwnership(
      tokenAddress1: string,
      tokenAddress2: string,
      priceOwnership: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get date after which the token price can potentially be set by an oracle (0 if price can not be set by an oracle).
     * @param tokenAddress Token address.
     */
    variablePriceStartDate(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Set date after which the token price can potentially be set by an oracle (0 if price can not be set by an oracle).
     * @param startDate Date after which token price can potentially be set by an oracle (0 if price can not be set by an oracle).
     * @param tokenAddress Token address.
     */
    setVariablePriceStartDate(
      tokenAddress: string,
      startDate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get price of the token.
     * @param tokenAddress1 Address of the token to be priced.
     * @param tokenAddress2 Address of the token to pay for token1.
     * @param tokenId1 ID/partition of the token2 (set to 0 bytes32 if price is set for all IDs/partitions).
     */
    getTokenPrice(
      tokenAddress1: string,
      tokenAddress2: string,
      tokenId1: BytesLike,
      tokenId2: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Set price of a token.
     * @param newPrice New price of the token.
     * @param tokenAddress1 Address of the token to be priced.
     * @param tokenAddress2 Address of the token to pay for token1.
     * @param tokenId1 ID/partition of the token1 (set to 0 bytes32 if price is set for all IDs/partitions).
     * @param tokenId2 ID/partition of the token2 (set to 0 bytes32 if price is set for all IDs/partitions).
     */
    setTokenPrice(
      tokenAddress1: string,
      tokenAddress2: string,
      tokenId1: BytesLike,
      tokenId2: BytesLike,
      newPrice: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get amount of token2 to pay to acquire the token1.
     * @param index Index of the DVP request.
     */
    getPrice(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the trade.
     * @param index Index of the trade.
     */
    getTrade(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the total number of requests in the DVP contract.
     */
    getNbTrades(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Indicate whether or not the DVP contract can receive the tokens or not. [USED FOR ERC1400 TOKENS ONLY]
     * [ERC1400TokensRecipient INTERFACE (1/2)]
     * @param data Information attached to the token transfer.
     * @param operatorData Information attached to the DVP transfer, by the operator.
     */
    canReceive(
      arg0: BytesLike,
      arg1: BytesLike,
      arg2: string,
      arg3: string,
      arg4: string,
      arg5: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Hook function executed when tokens are sent to the DVP contract. [USED FOR ERC1400 TOKENS ONLY]
     * [ERC1400TokensRecipient INTERFACE (2/2)]
     * @param data Information attached to the token transfer.
     * @param from Token holder.
     * @param operatorData Information attached to the DVP transfer, by the operator.
     * @param partition Name of the partition.
     * @param to Token recipient.
     * @param value Number of tokens to transfer.
     */
    tokensReceived(
      arg0: BytesLike,
      partition: BytesLike,
      arg2: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    requestTrade(
      inputData: TradeRequestInputStruct,
      preimage: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Accept a given trade (+ potentially escrow tokens).
     * @param index Index of the trade to be accepted.
     */
    acceptTrade(
      index: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Accept a given trade (+ potentially escrow tokens).
     * @param index Index of the trade to be accepted.
     */
    acceptTradeWithPreimage(
      index: BigNumberish,
      preimage: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Verify if a trade has been accepted by the token holders. The trade needs to be accepted by both parties (token holders) before it gets executed.
     * @param index Index of the trade to be accepted.
     */
    getTradeAcceptanceStatus(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    approveTrade(
      index: BigNumberish,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Approve a trade (if the tokens involved in the trade are controlled) This function can only be called by a token controller of one of the tokens involved in the trade. Indeed, when a token smart contract is controlled by an owner, the owner can decide to open the secondary market by:  - Allowlisting the DVP smart contract  - Setting "token controllers" in the DVP smart contract, in order to approve all the trades made with his token
     * @param approved 'true' if trade is approved, 'false' if not.
     * @param index Index of the trade to be executed.
     */
    approveTradeWithPreimage(
      index: BigNumberish,
      approved: boolean,
      preimage: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Verify if a trade has been approved by the token controllers. In case a given token has token controllers, those need to validate the trade before it gets executed.
     * @param index Index of the trade to be approved.
     */
    getTradeApprovalStatus(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    executeTrade(
      index: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Execute a trade in the DVP contract if possible (e.g. if tokens have been esccrowed, in case it is required). This function can only be called by the executer specified at trade creation. If no executer is specified, the trade can be launched by anyone.
     * @param index Index of the trade to be executed.
     */
    executeTradeWithPreimage(
      index: BigNumberish,
      preimage: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    forceTrade(
      index: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Force a trade execution in the DVP contract by transferring tokens back to their target recipients.
     * @param index Index of the trade to be forced.
     */
    forceTradeWithPreimage(
      index: BigNumberish,
      preimage: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Cancel a trade execution in the DVP contract by transferring tokens back to their initial owners.
     * @param index Index of the trade to be cancelled.
     */
    cancelTrade(
      index: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Renounce ownership of the contract.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the list of trade executers as defined by the DVP contract.
     */
    tradeExecuters(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Set list of trade executers for the DVP contract.
     * @param operators Trade executers addresses.
     */
    setTradeExecuters(
      operators: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the list of token controllers for a given token.
     * @param tokenAddress Token address.
     */
    tokenControllers(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Set list of token controllers for a given token.
     * @param operators Operators addresses.
     * @param tokenAddress Token address.
     */
    setTokenControllers(
      tokenAddress: string,
      operators: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the list of price oracles for a given token.
     * @param tokenAddress Token address.
     */
    priceOracles(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Set list of price oracles for a given token.
     * @param oracles Oracles addresses.
     * @param tokenAddress Token address.
     */
    setPriceOracles(
      tokenAddress: string,
      oracles: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get price of the token.
     * @param tokenAddress1 Address of the token to be priced.
     * @param tokenAddress2 Address of the token to pay for token1.
     */
    getPriceOwnership(
      tokenAddress1: string,
      tokenAddress2: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Take ownership for setting the price of a token.
     * @param tokenAddress1 Address of the token to be priced.
     * @param tokenAddress2 Address of the token to pay for token1.
     */
    setPriceOwnership(
      tokenAddress1: string,
      tokenAddress2: string,
      priceOwnership: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get date after which the token price can potentially be set by an oracle (0 if price can not be set by an oracle).
     * @param tokenAddress Token address.
     */
    variablePriceStartDate(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Set date after which the token price can potentially be set by an oracle (0 if price can not be set by an oracle).
     * @param startDate Date after which token price can potentially be set by an oracle (0 if price can not be set by an oracle).
     * @param tokenAddress Token address.
     */
    setVariablePriceStartDate(
      tokenAddress: string,
      startDate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get price of the token.
     * @param tokenAddress1 Address of the token to be priced.
     * @param tokenAddress2 Address of the token to pay for token1.
     * @param tokenId1 ID/partition of the token2 (set to 0 bytes32 if price is set for all IDs/partitions).
     */
    getTokenPrice(
      tokenAddress1: string,
      tokenAddress2: string,
      tokenId1: BytesLike,
      tokenId2: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Set price of a token.
     * @param newPrice New price of the token.
     * @param tokenAddress1 Address of the token to be priced.
     * @param tokenAddress2 Address of the token to pay for token1.
     * @param tokenId1 ID/partition of the token1 (set to 0 bytes32 if price is set for all IDs/partitions).
     * @param tokenId2 ID/partition of the token2 (set to 0 bytes32 if price is set for all IDs/partitions).
     */
    setTokenPrice(
      tokenAddress1: string,
      tokenAddress2: string,
      tokenId1: BytesLike,
      tokenId2: BytesLike,
      newPrice: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get amount of token2 to pay to acquire the token1.
     * @param index Index of the DVP request.
     */
    getPrice(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the trade.
     * @param index Index of the trade.
     */
    getTrade(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the total number of requests in the DVP contract.
     */
    getNbTrades(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
