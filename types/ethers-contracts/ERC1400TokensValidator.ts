/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";

export type ValidateDataStruct = {
  token: string;
  payload: BytesLike;
  partition: BytesLike;
  operator: string;
  from: string;
  to: string;
  value: BigNumberish;
  data: BytesLike;
  operatorData: BytesLike;
};

export type ValidateDataStructOutput = [
  string,
  string,
  string,
  string,
  string,
  string,
  BigNumber,
  string,
  string
] & {
  token: string;
  payload: string;
  partition: string;
  operator: string;
  from: string;
  to: string;
  value: BigNumber;
  data: string;
  operatorData: string;
};

export interface ERC1400TokensValidatorInterface extends utils.Interface {
  functions: {
    "addAllowlistAdmin(address,address)": FunctionFragment;
    "addAllowlisted(address,address)": FunctionFragment;
    "addBlocklistAdmin(address,address)": FunctionFragment;
    "addBlocklisted(address,address)": FunctionFragment;
    "addCertificateSigner(address,address)": FunctionFragment;
    "addPauser(address,address)": FunctionFragment;
    "canImplementInterfaceForAddress(bytes32,address)": FunctionFragment;
    "isAllowlistAdmin(address,address)": FunctionFragment;
    "isAllowlisted(address,address)": FunctionFragment;
    "isBlocklistAdmin(address,address)": FunctionFragment;
    "isBlocklisted(address,address)": FunctionFragment;
    "isCertificateSigner(address,address)": FunctionFragment;
    "isPauser(address,address)": FunctionFragment;
    "pause(address)": FunctionFragment;
    "paused(address)": FunctionFragment;
    "removeAllowlistAdmin(address,address)": FunctionFragment;
    "removeAllowlisted(address,address)": FunctionFragment;
    "removeBlocklistAdmin(address,address)": FunctionFragment;
    "removeBlocklisted(address,address)": FunctionFragment;
    "removeCertificateSigner(address,address)": FunctionFragment;
    "removePauser(address,address)": FunctionFragment;
    "renounceAllowlistAdmin(address)": FunctionFragment;
    "renounceBlocklistAdmin(address)": FunctionFragment;
    "renounceCertificateSigner(address)": FunctionFragment;
    "renouncePauser(address)": FunctionFragment;
    "unpause(address)": FunctionFragment;
    "retrieveTokenSetup(address)": FunctionFragment;
    "registerTokenSetup(address,uint8,bool,bool,bool,bool,address[])": FunctionFragment;
    "canValidate((address,bytes,bytes32,address,address,address,uint256,bytes,bytes))": FunctionFragment;
    "tokensToValidate(bytes,bytes32,address,address,address,uint256,bytes,bytes)": FunctionFragment;
    "granularityByPartition(address,bytes32)": FunctionFragment;
    "setGranularityByPartition(address,bytes32,uint256)": FunctionFragment;
    "preHoldFor(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)": FunctionFragment;
    "preHoldForWithExpirationDate(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)": FunctionFragment;
    "hold(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)": FunctionFragment;
    "holdWithExpirationDate(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)": FunctionFragment;
    "holdFrom(address,bytes32,address,address,address,bytes32,uint256,uint256,bytes32,bytes)": FunctionFragment;
    "holdFromWithExpirationDate(address,bytes32,address,address,address,bytes32,uint256,uint256,bytes32,bytes)": FunctionFragment;
    "releaseHold(address,bytes32)": FunctionFragment;
    "renewHold(address,bytes32,uint256,bytes)": FunctionFragment;
    "renewHoldWithExpirationDate(address,bytes32,uint256,bytes)": FunctionFragment;
    "executeHold(address,bytes32,uint256,bytes32)": FunctionFragment;
    "executeHoldAndKeepOpen(address,bytes32,uint256,bytes32)": FunctionFragment;
    "retrieveHoldData(address,bytes32)": FunctionFragment;
    "totalSupplyOnHold(address)": FunctionFragment;
    "totalSupplyOnHoldByPartition(address,bytes32)": FunctionFragment;
    "balanceOnHold(address,address)": FunctionFragment;
    "balanceOnHoldByPartition(address,bytes32,address)": FunctionFragment;
    "spendableBalanceOf(address,address)": FunctionFragment;
    "spendableBalanceOfByPartition(address,bytes32,address)": FunctionFragment;
    "usedCertificateNonce(address,address)": FunctionFragment;
    "usedCertificateSalt(address,bytes32)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "addAllowlistAdmin",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "addAllowlisted",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "addBlocklistAdmin",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "addBlocklisted",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "addCertificateSigner",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "addPauser",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "canImplementInterfaceForAddress",
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "isAllowlistAdmin",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "isAllowlisted",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "isBlocklistAdmin",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "isBlocklisted",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "isCertificateSigner",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "isPauser",
    values: [string, string]
  ): string;
  encodeFunctionData(functionFragment: "pause", values: [string]): string;
  encodeFunctionData(functionFragment: "paused", values: [string]): string;
  encodeFunctionData(
    functionFragment: "removeAllowlistAdmin",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "removeAllowlisted",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "removeBlocklistAdmin",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "removeBlocklisted",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "removeCertificateSigner",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "removePauser",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceAllowlistAdmin",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceBlocklistAdmin",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceCertificateSigner",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "renouncePauser",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "unpause", values: [string]): string;
  encodeFunctionData(
    functionFragment: "retrieveTokenSetup",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "registerTokenSetup",
    values: [string, BigNumberish, boolean, boolean, boolean, boolean, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "canValidate",
    values: [ValidateDataStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "tokensToValidate",
    values: [
      BytesLike,
      BytesLike,
      string,
      string,
      string,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "granularityByPartition",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setGranularityByPartition",
    values: [string, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "preHoldFor",
    values: [
      string,
      BytesLike,
      string,
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "preHoldForWithExpirationDate",
    values: [
      string,
      BytesLike,
      string,
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "hold",
    values: [
      string,
      BytesLike,
      string,
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "holdWithExpirationDate",
    values: [
      string,
      BytesLike,
      string,
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "holdFrom",
    values: [
      string,
      BytesLike,
      string,
      string,
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "holdFromWithExpirationDate",
    values: [
      string,
      BytesLike,
      string,
      string,
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "releaseHold",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "renewHold",
    values: [string, BytesLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "renewHoldWithExpirationDate",
    values: [string, BytesLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "executeHold",
    values: [string, BytesLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "executeHoldAndKeepOpen",
    values: [string, BytesLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "retrieveHoldData",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "totalSupplyOnHold",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "totalSupplyOnHoldByPartition",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOnHold",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOnHoldByPartition",
    values: [string, BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "spendableBalanceOf",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "spendableBalanceOfByPartition",
    values: [string, BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "usedCertificateNonce",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "usedCertificateSalt",
    values: [string, BytesLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "addAllowlistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addAllowlisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addBlocklistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addBlocklisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addCertificateSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "addPauser", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "canImplementInterfaceForAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isAllowlistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isAllowlisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isBlocklistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isBlocklisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isCertificateSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isPauser", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "removeAllowlistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeAllowlisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeBlocklistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeBlocklisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeCertificateSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removePauser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceAllowlistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceBlocklistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceCertificateSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renouncePauser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "retrieveTokenSetup",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerTokenSetup",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "canValidate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokensToValidate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "granularityByPartition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setGranularityByPartition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "preHoldFor", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "preHoldForWithExpirationDate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "hold", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "holdWithExpirationDate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "holdFrom", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "holdFromWithExpirationDate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "releaseHold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "renewHold", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renewHoldWithExpirationDate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeHold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeHoldAndKeepOpen",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "retrieveHoldData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalSupplyOnHold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalSupplyOnHoldByPartition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "balanceOnHold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "balanceOnHoldByPartition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "spendableBalanceOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "spendableBalanceOfByPartition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "usedCertificateNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "usedCertificateSalt",
    data: BytesLike
  ): Result;

  events: {
    "AllowlistAdminAdded(address,address)": EventFragment;
    "AllowlistAdminRemoved(address,address)": EventFragment;
    "AllowlistedAdded(address,address)": EventFragment;
    "AllowlistedRemoved(address,address)": EventFragment;
    "BlocklistAdminAdded(address,address)": EventFragment;
    "BlocklistAdminRemoved(address,address)": EventFragment;
    "BlocklistedAdded(address,address)": EventFragment;
    "BlocklistedRemoved(address,address)": EventFragment;
    "CertificateSignerAdded(address,address)": EventFragment;
    "CertificateSignerRemoved(address,address)": EventFragment;
    "HoldCreated(address,bytes32,bytes32,address,address,address,uint256,uint256,bytes32)": EventFragment;
    "HoldExecuted(address,bytes32,address,uint256,uint256,bytes32)": EventFragment;
    "HoldExecutedAndKeptOpen(address,bytes32,address,uint256,uint256,bytes32)": EventFragment;
    "HoldReleased(address,bytes32,address,uint8)": EventFragment;
    "HoldRenewed(address,bytes32,address,uint256,uint256)": EventFragment;
    "Paused(address,address)": EventFragment;
    "PauserAdded(address,address)": EventFragment;
    "PauserRemoved(address,address)": EventFragment;
    "Unpaused(address,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AllowlistAdminAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AllowlistAdminRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AllowlistedAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AllowlistedRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BlocklistAdminAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BlocklistAdminRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BlocklistedAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BlocklistedRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CertificateSignerAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CertificateSignerRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "HoldCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "HoldExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "HoldExecutedAndKeptOpen"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "HoldReleased"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "HoldRenewed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Paused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PauserAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PauserRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unpaused"): EventFragment;
}

export type AllowlistAdminAddedEvent = TypedEvent<
  [string, string],
  { token: string; account: string }
>;

export type AllowlistAdminAddedEventFilter =
  TypedEventFilter<AllowlistAdminAddedEvent>;

export type AllowlistAdminRemovedEvent = TypedEvent<
  [string, string],
  { token: string; account: string }
>;

export type AllowlistAdminRemovedEventFilter =
  TypedEventFilter<AllowlistAdminRemovedEvent>;

export type AllowlistedAddedEvent = TypedEvent<
  [string, string],
  { token: string; account: string }
>;

export type AllowlistedAddedEventFilter =
  TypedEventFilter<AllowlistedAddedEvent>;

export type AllowlistedRemovedEvent = TypedEvent<
  [string, string],
  { token: string; account: string }
>;

export type AllowlistedRemovedEventFilter =
  TypedEventFilter<AllowlistedRemovedEvent>;

export type BlocklistAdminAddedEvent = TypedEvent<
  [string, string],
  { token: string; account: string }
>;

export type BlocklistAdminAddedEventFilter =
  TypedEventFilter<BlocklistAdminAddedEvent>;

export type BlocklistAdminRemovedEvent = TypedEvent<
  [string, string],
  { token: string; account: string }
>;

export type BlocklistAdminRemovedEventFilter =
  TypedEventFilter<BlocklistAdminRemovedEvent>;

export type BlocklistedAddedEvent = TypedEvent<
  [string, string],
  { token: string; account: string }
>;

export type BlocklistedAddedEventFilter =
  TypedEventFilter<BlocklistedAddedEvent>;

export type BlocklistedRemovedEvent = TypedEvent<
  [string, string],
  { token: string; account: string }
>;

export type BlocklistedRemovedEventFilter =
  TypedEventFilter<BlocklistedRemovedEvent>;

export type CertificateSignerAddedEvent = TypedEvent<
  [string, string],
  { token: string; account: string }
>;

export type CertificateSignerAddedEventFilter =
  TypedEventFilter<CertificateSignerAddedEvent>;

export type CertificateSignerRemovedEvent = TypedEvent<
  [string, string],
  { token: string; account: string }
>;

export type CertificateSignerRemovedEventFilter =
  TypedEventFilter<CertificateSignerRemovedEvent>;

export type HoldCreatedEvent = TypedEvent<
  [
    string,
    string,
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    string
  ],
  {
    token: string;
    holdId: string;
    partition: string;
    sender: string;
    recipient: string;
    notary: string;
    value: BigNumber;
    expiration: BigNumber;
    secretHash: string;
  }
>;

export type HoldCreatedEventFilter = TypedEventFilter<HoldCreatedEvent>;

export type HoldExecutedEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber, string],
  {
    token: string;
    holdId: string;
    notary: string;
    heldValue: BigNumber;
    transferredValue: BigNumber;
    secret: string;
  }
>;

export type HoldExecutedEventFilter = TypedEventFilter<HoldExecutedEvent>;

export type HoldExecutedAndKeptOpenEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber, string],
  {
    token: string;
    holdId: string;
    notary: string;
    heldValue: BigNumber;
    transferredValue: BigNumber;
    secret: string;
  }
>;

export type HoldExecutedAndKeptOpenEventFilter =
  TypedEventFilter<HoldExecutedAndKeptOpenEvent>;

export type HoldReleasedEvent = TypedEvent<
  [string, string, string, number],
  { token: string; holdId: string; notary: string; status: number }
>;

export type HoldReleasedEventFilter = TypedEventFilter<HoldReleasedEvent>;

export type HoldRenewedEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  {
    token: string;
    holdId: string;
    notary: string;
    oldExpiration: BigNumber;
    newExpiration: BigNumber;
  }
>;

export type HoldRenewedEventFilter = TypedEventFilter<HoldRenewedEvent>;

export type PausedEvent = TypedEvent<
  [string, string],
  { token: string; account: string }
>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export type PauserAddedEvent = TypedEvent<
  [string, string],
  { token: string; account: string }
>;

export type PauserAddedEventFilter = TypedEventFilter<PauserAddedEvent>;

export type PauserRemovedEvent = TypedEvent<
  [string, string],
  { token: string; account: string }
>;

export type PauserRemovedEventFilter = TypedEventFilter<PauserRemovedEvent>;

export type UnpausedEvent = TypedEvent<
  [string, string],
  { token: string; account: string }
>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface ERC1400TokensValidator extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ERC1400TokensValidatorInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    addAllowlistAdmin(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    addAllowlisted(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    addBlocklistAdmin(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    addBlocklisted(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    addCertificateSigner(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    addPauser(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    isAllowlistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isAllowlisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isBlocklistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isBlocklisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isCertificateSigner(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isPauser(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * called by the owner to pause, triggers stopped state
     */
    pause(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     */
    paused(token: string, overrides?: CallOverrides): Promise<[boolean]>;

    removeAllowlistAdmin(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    removeAllowlisted(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    removeBlocklistAdmin(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    removeBlocklisted(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    removeCertificateSigner(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    removePauser(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    renounceAllowlistAdmin(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    renounceBlocklistAdmin(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    renounceCertificateSigner(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    renouncePauser(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * called by the owner to unpause, returns to normal state
     */
    unpause(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get the list of token controllers for a given token.
     */
    retrieveTokenSetup(
      token: string,
      overrides?: CallOverrides
    ): Promise<[number, boolean, boolean, boolean, boolean, string[]]>;

    /**
     * Register token setup.
     */
    registerTokenSetup(
      token: string,
      certificateActivated: BigNumberish,
      allowlistActivated: boolean,
      blocklistActivated: boolean,
      granularityByPartitionActivated: boolean,
      holdsActivated: boolean,
      operators: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    canValidate(
      data: ValidateDataStruct,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Function called by the token contract before executing a transfer.
     * @param data Extra information.
     * @param from Token holder.
     * @param operator Address which triggered the balance decrease (through transfer or redemption).
     * @param operatorData Extra information, attached by the operator (if any).
     * @param partition Name of the partition (left empty for ERC20 transfer).
     * @param payload Payload of the initial transaction.
     * @param to Token recipient for a transfer and 0x for a redemption.
     * @param value Number of tokens the token holder balance is decreased by.
     */
    tokensToValidate(
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get granularity for a given partition.
     * @param partition Name of the partition.
     * @param token Token address.
     */
    granularityByPartition(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Set partition granularity
     */
    setGranularityByPartition(
      token: string,
      partition: BytesLike,
      granularity: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Create a new token pre-hold.
     */
    preHoldFor(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Create a new token pre-hold with expiration date.
     */
    preHoldForWithExpirationDate(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Create a new token hold.
     */
    hold(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Create a new token hold with expiration date.
     */
    holdWithExpirationDate(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Create a new token hold on behalf of the token holder.
     */
    holdFrom(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Create a new token hold with expiration date on behalf of the token holder.
     */
    holdFromWithExpirationDate(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Release token hold.
     */
    releaseHold(
      token: string,
      holdId: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Renew hold.
     */
    renewHold(
      token: string,
      holdId: BytesLike,
      timeToExpiration: BigNumberish,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Renew hold with expiration time.
     */
    renewHoldWithExpirationDate(
      token: string,
      holdId: BytesLike,
      expiration: BigNumberish,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Execute hold.
     */
    executeHold(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Execute hold and keep open.
     */
    executeHoldAndKeepOpen(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Retrieve hold data.
     */
    retrieveHoldData(
      token: string,
      holdId: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        string,
        string,
        number
      ] & {
        partition: string;
        sender: string;
        recipient: string;
        notary: string;
        value: BigNumber;
        expiration: BigNumber;
        secretHash: string;
        secret: string;
        status: number;
      }
    >;

    /**
     * Total supply on hold.
     */
    totalSupplyOnHold(
      token: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Total supply on hold for a specific partition.
     */
    totalSupplyOnHoldByPartition(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Get balance on hold of a tokenholder.
     */
    balanceOnHold(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Get balance on hold of a tokenholder for a specific partition.
     */
    balanceOnHoldByPartition(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Get spendable balance of a tokenholder.
     */
    spendableBalanceOf(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Get spendable balance of a tokenholder for a specific partition.
     */
    spendableBalanceOfByPartition(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Get state of certificate (used or not).
     * @param sender Address whom to check the counter of.
     * @param token Token address.
     */
    usedCertificateNonce(
      token: string,
      sender: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Get state of certificate (used or not).
     * @param salt First 32 bytes of certificate whose validity is being checked.
     * @param token Token address.
     */
    usedCertificateSalt(
      token: string,
      salt: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;
  };

  addAllowlistAdmin(
    token: string,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  addAllowlisted(
    token: string,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  addBlocklistAdmin(
    token: string,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  addBlocklisted(
    token: string,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  addCertificateSigner(
    token: string,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  addPauser(
    token: string,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  canImplementInterfaceForAddress(
    interfaceHash: BytesLike,
    arg1: string,
    overrides?: CallOverrides
  ): Promise<string>;

  isAllowlistAdmin(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isAllowlisted(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isBlocklistAdmin(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isBlocklisted(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isCertificateSigner(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isPauser(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * called by the owner to pause, triggers stopped state
   */
  pause(
    token: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   */
  paused(token: string, overrides?: CallOverrides): Promise<boolean>;

  removeAllowlistAdmin(
    token: string,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  removeAllowlisted(
    token: string,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  removeBlocklistAdmin(
    token: string,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  removeBlocklisted(
    token: string,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  removeCertificateSigner(
    token: string,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  removePauser(
    token: string,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  renounceAllowlistAdmin(
    token: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  renounceBlocklistAdmin(
    token: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  renounceCertificateSigner(
    token: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  renouncePauser(
    token: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * called by the owner to unpause, returns to normal state
   */
  unpause(
    token: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get the list of token controllers for a given token.
   */
  retrieveTokenSetup(
    token: string,
    overrides?: CallOverrides
  ): Promise<[number, boolean, boolean, boolean, boolean, string[]]>;

  /**
   * Register token setup.
   */
  registerTokenSetup(
    token: string,
    certificateActivated: BigNumberish,
    allowlistActivated: boolean,
    blocklistActivated: boolean,
    granularityByPartitionActivated: boolean,
    holdsActivated: boolean,
    operators: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  canValidate(
    data: ValidateDataStruct,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Function called by the token contract before executing a transfer.
   * @param data Extra information.
   * @param from Token holder.
   * @param operator Address which triggered the balance decrease (through transfer or redemption).
   * @param operatorData Extra information, attached by the operator (if any).
   * @param partition Name of the partition (left empty for ERC20 transfer).
   * @param payload Payload of the initial transaction.
   * @param to Token recipient for a transfer and 0x for a redemption.
   * @param value Number of tokens the token holder balance is decreased by.
   */
  tokensToValidate(
    payload: BytesLike,
    partition: BytesLike,
    operator: string,
    from: string,
    to: string,
    value: BigNumberish,
    data: BytesLike,
    operatorData: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get granularity for a given partition.
   * @param partition Name of the partition.
   * @param token Token address.
   */
  granularityByPartition(
    token: string,
    partition: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Set partition granularity
   */
  setGranularityByPartition(
    token: string,
    partition: BytesLike,
    granularity: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Create a new token pre-hold.
   */
  preHoldFor(
    token: string,
    holdId: BytesLike,
    recipient: string,
    notary: string,
    partition: BytesLike,
    value: BigNumberish,
    timeToExpiration: BigNumberish,
    secretHash: BytesLike,
    certificate: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Create a new token pre-hold with expiration date.
   */
  preHoldForWithExpirationDate(
    token: string,
    holdId: BytesLike,
    recipient: string,
    notary: string,
    partition: BytesLike,
    value: BigNumberish,
    expiration: BigNumberish,
    secretHash: BytesLike,
    certificate: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Create a new token hold.
   */
  hold(
    token: string,
    holdId: BytesLike,
    recipient: string,
    notary: string,
    partition: BytesLike,
    value: BigNumberish,
    timeToExpiration: BigNumberish,
    secretHash: BytesLike,
    certificate: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Create a new token hold with expiration date.
   */
  holdWithExpirationDate(
    token: string,
    holdId: BytesLike,
    recipient: string,
    notary: string,
    partition: BytesLike,
    value: BigNumberish,
    expiration: BigNumberish,
    secretHash: BytesLike,
    certificate: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Create a new token hold on behalf of the token holder.
   */
  holdFrom(
    token: string,
    holdId: BytesLike,
    sender: string,
    recipient: string,
    notary: string,
    partition: BytesLike,
    value: BigNumberish,
    timeToExpiration: BigNumberish,
    secretHash: BytesLike,
    certificate: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Create a new token hold with expiration date on behalf of the token holder.
   */
  holdFromWithExpirationDate(
    token: string,
    holdId: BytesLike,
    sender: string,
    recipient: string,
    notary: string,
    partition: BytesLike,
    value: BigNumberish,
    expiration: BigNumberish,
    secretHash: BytesLike,
    certificate: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Release token hold.
   */
  releaseHold(
    token: string,
    holdId: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Renew hold.
   */
  renewHold(
    token: string,
    holdId: BytesLike,
    timeToExpiration: BigNumberish,
    certificate: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Renew hold with expiration time.
   */
  renewHoldWithExpirationDate(
    token: string,
    holdId: BytesLike,
    expiration: BigNumberish,
    certificate: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Execute hold.
   */
  executeHold(
    token: string,
    holdId: BytesLike,
    value: BigNumberish,
    secret: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Execute hold and keep open.
   */
  executeHoldAndKeepOpen(
    token: string,
    holdId: BytesLike,
    value: BigNumberish,
    secret: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Retrieve hold data.
   */
  retrieveHoldData(
    token: string,
    holdId: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [
      string,
      string,
      string,
      string,
      BigNumber,
      BigNumber,
      string,
      string,
      number
    ] & {
      partition: string;
      sender: string;
      recipient: string;
      notary: string;
      value: BigNumber;
      expiration: BigNumber;
      secretHash: string;
      secret: string;
      status: number;
    }
  >;

  /**
   * Total supply on hold.
   */
  totalSupplyOnHold(
    token: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Total supply on hold for a specific partition.
   */
  totalSupplyOnHoldByPartition(
    token: string,
    partition: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Get balance on hold of a tokenholder.
   */
  balanceOnHold(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Get balance on hold of a tokenholder for a specific partition.
   */
  balanceOnHoldByPartition(
    token: string,
    partition: BytesLike,
    account: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Get spendable balance of a tokenholder.
   */
  spendableBalanceOf(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Get spendable balance of a tokenholder for a specific partition.
   */
  spendableBalanceOfByPartition(
    token: string,
    partition: BytesLike,
    account: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Get state of certificate (used or not).
   * @param sender Address whom to check the counter of.
   * @param token Token address.
   */
  usedCertificateNonce(
    token: string,
    sender: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Get state of certificate (used or not).
   * @param salt First 32 bytes of certificate whose validity is being checked.
   * @param token Token address.
   */
  usedCertificateSalt(
    token: string,
    salt: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  callStatic: {
    addAllowlistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    addAllowlisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    addBlocklistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    addBlocklisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    addCertificateSigner(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    addPauser(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<string>;

    isAllowlistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isAllowlisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isBlocklistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isBlocklisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isCertificateSigner(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isPauser(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * called by the owner to pause, triggers stopped state
     */
    pause(token: string, overrides?: CallOverrides): Promise<void>;

    /**
     */
    paused(token: string, overrides?: CallOverrides): Promise<boolean>;

    removeAllowlistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    removeAllowlisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    removeBlocklistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    removeBlocklisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    removeCertificateSigner(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    removePauser(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceAllowlistAdmin(
      token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceBlocklistAdmin(
      token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceCertificateSigner(
      token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    renouncePauser(token: string, overrides?: CallOverrides): Promise<void>;

    /**
     * called by the owner to unpause, returns to normal state
     */
    unpause(token: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Get the list of token controllers for a given token.
     */
    retrieveTokenSetup(
      token: string,
      overrides?: CallOverrides
    ): Promise<[number, boolean, boolean, boolean, boolean, string[]]>;

    /**
     * Register token setup.
     */
    registerTokenSetup(
      token: string,
      certificateActivated: BigNumberish,
      allowlistActivated: boolean,
      blocklistActivated: boolean,
      granularityByPartitionActivated: boolean,
      holdsActivated: boolean,
      operators: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    canValidate(
      data: ValidateDataStruct,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Function called by the token contract before executing a transfer.
     * @param data Extra information.
     * @param from Token holder.
     * @param operator Address which triggered the balance decrease (through transfer or redemption).
     * @param operatorData Extra information, attached by the operator (if any).
     * @param partition Name of the partition (left empty for ERC20 transfer).
     * @param payload Payload of the initial transaction.
     * @param to Token recipient for a transfer and 0x for a redemption.
     * @param value Number of tokens the token holder balance is decreased by.
     */
    tokensToValidate(
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get granularity for a given partition.
     * @param partition Name of the partition.
     * @param token Token address.
     */
    granularityByPartition(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Set partition granularity
     */
    setGranularityByPartition(
      token: string,
      partition: BytesLike,
      granularity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Create a new token pre-hold.
     */
    preHoldFor(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Create a new token pre-hold with expiration date.
     */
    preHoldForWithExpirationDate(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Create a new token hold.
     */
    hold(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Create a new token hold with expiration date.
     */
    holdWithExpirationDate(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Create a new token hold on behalf of the token holder.
     */
    holdFrom(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Create a new token hold with expiration date on behalf of the token holder.
     */
    holdFromWithExpirationDate(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Release token hold.
     */
    releaseHold(
      token: string,
      holdId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Renew hold.
     */
    renewHold(
      token: string,
      holdId: BytesLike,
      timeToExpiration: BigNumberish,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Renew hold with expiration time.
     */
    renewHoldWithExpirationDate(
      token: string,
      holdId: BytesLike,
      expiration: BigNumberish,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Execute hold.
     */
    executeHold(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Execute hold and keep open.
     */
    executeHoldAndKeepOpen(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Retrieve hold data.
     */
    retrieveHoldData(
      token: string,
      holdId: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        string,
        string,
        number
      ] & {
        partition: string;
        sender: string;
        recipient: string;
        notary: string;
        value: BigNumber;
        expiration: BigNumber;
        secretHash: string;
        secret: string;
        status: number;
      }
    >;

    /**
     * Total supply on hold.
     */
    totalSupplyOnHold(
      token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Total supply on hold for a specific partition.
     */
    totalSupplyOnHoldByPartition(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get balance on hold of a tokenholder.
     */
    balanceOnHold(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get balance on hold of a tokenholder for a specific partition.
     */
    balanceOnHoldByPartition(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get spendable balance of a tokenholder.
     */
    spendableBalanceOf(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get spendable balance of a tokenholder for a specific partition.
     */
    spendableBalanceOfByPartition(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get state of certificate (used or not).
     * @param sender Address whom to check the counter of.
     * @param token Token address.
     */
    usedCertificateNonce(
      token: string,
      sender: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get state of certificate (used or not).
     * @param salt First 32 bytes of certificate whose validity is being checked.
     * @param token Token address.
     */
    usedCertificateSalt(
      token: string,
      salt: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {
    "AllowlistAdminAdded(address,address)"(
      token?: string | null,
      account?: string | null
    ): AllowlistAdminAddedEventFilter;
    AllowlistAdminAdded(
      token?: string | null,
      account?: string | null
    ): AllowlistAdminAddedEventFilter;

    "AllowlistAdminRemoved(address,address)"(
      token?: string | null,
      account?: string | null
    ): AllowlistAdminRemovedEventFilter;
    AllowlistAdminRemoved(
      token?: string | null,
      account?: string | null
    ): AllowlistAdminRemovedEventFilter;

    "AllowlistedAdded(address,address)"(
      token?: string | null,
      account?: string | null
    ): AllowlistedAddedEventFilter;
    AllowlistedAdded(
      token?: string | null,
      account?: string | null
    ): AllowlistedAddedEventFilter;

    "AllowlistedRemoved(address,address)"(
      token?: string | null,
      account?: string | null
    ): AllowlistedRemovedEventFilter;
    AllowlistedRemoved(
      token?: string | null,
      account?: string | null
    ): AllowlistedRemovedEventFilter;

    "BlocklistAdminAdded(address,address)"(
      token?: string | null,
      account?: string | null
    ): BlocklistAdminAddedEventFilter;
    BlocklistAdminAdded(
      token?: string | null,
      account?: string | null
    ): BlocklistAdminAddedEventFilter;

    "BlocklistAdminRemoved(address,address)"(
      token?: string | null,
      account?: string | null
    ): BlocklistAdminRemovedEventFilter;
    BlocklistAdminRemoved(
      token?: string | null,
      account?: string | null
    ): BlocklistAdminRemovedEventFilter;

    "BlocklistedAdded(address,address)"(
      token?: string | null,
      account?: string | null
    ): BlocklistedAddedEventFilter;
    BlocklistedAdded(
      token?: string | null,
      account?: string | null
    ): BlocklistedAddedEventFilter;

    "BlocklistedRemoved(address,address)"(
      token?: string | null,
      account?: string | null
    ): BlocklistedRemovedEventFilter;
    BlocklistedRemoved(
      token?: string | null,
      account?: string | null
    ): BlocklistedRemovedEventFilter;

    "CertificateSignerAdded(address,address)"(
      token?: string | null,
      account?: string | null
    ): CertificateSignerAddedEventFilter;
    CertificateSignerAdded(
      token?: string | null,
      account?: string | null
    ): CertificateSignerAddedEventFilter;

    "CertificateSignerRemoved(address,address)"(
      token?: string | null,
      account?: string | null
    ): CertificateSignerRemovedEventFilter;
    CertificateSignerRemoved(
      token?: string | null,
      account?: string | null
    ): CertificateSignerRemovedEventFilter;

    "HoldCreated(address,bytes32,bytes32,address,address,address,uint256,uint256,bytes32)"(
      token?: string | null,
      holdId?: BytesLike | null,
      partition?: null,
      sender?: null,
      recipient?: null,
      notary?: string | null,
      value?: null,
      expiration?: null,
      secretHash?: null
    ): HoldCreatedEventFilter;
    HoldCreated(
      token?: string | null,
      holdId?: BytesLike | null,
      partition?: null,
      sender?: null,
      recipient?: null,
      notary?: string | null,
      value?: null,
      expiration?: null,
      secretHash?: null
    ): HoldCreatedEventFilter;

    "HoldExecuted(address,bytes32,address,uint256,uint256,bytes32)"(
      token?: string | null,
      holdId?: null,
      notary?: string | null,
      heldValue?: null,
      transferredValue?: null,
      secret?: null
    ): HoldExecutedEventFilter;
    HoldExecuted(
      token?: string | null,
      holdId?: null,
      notary?: string | null,
      heldValue?: null,
      transferredValue?: null,
      secret?: null
    ): HoldExecutedEventFilter;

    "HoldExecutedAndKeptOpen(address,bytes32,address,uint256,uint256,bytes32)"(
      token?: string | null,
      holdId?: null,
      notary?: string | null,
      heldValue?: null,
      transferredValue?: null,
      secret?: null
    ): HoldExecutedAndKeptOpenEventFilter;
    HoldExecutedAndKeptOpen(
      token?: string | null,
      holdId?: null,
      notary?: string | null,
      heldValue?: null,
      transferredValue?: null,
      secret?: null
    ): HoldExecutedAndKeptOpenEventFilter;

    "HoldReleased(address,bytes32,address,uint8)"(
      token?: string | null,
      holdId?: null,
      notary?: string | null,
      status?: null
    ): HoldReleasedEventFilter;
    HoldReleased(
      token?: string | null,
      holdId?: null,
      notary?: string | null,
      status?: null
    ): HoldReleasedEventFilter;

    "HoldRenewed(address,bytes32,address,uint256,uint256)"(
      token?: string | null,
      holdId?: null,
      notary?: string | null,
      oldExpiration?: null,
      newExpiration?: null
    ): HoldRenewedEventFilter;
    HoldRenewed(
      token?: string | null,
      holdId?: null,
      notary?: string | null,
      oldExpiration?: null,
      newExpiration?: null
    ): HoldRenewedEventFilter;

    "Paused(address,address)"(
      token?: string | null,
      account?: null
    ): PausedEventFilter;
    Paused(token?: string | null, account?: null): PausedEventFilter;

    "PauserAdded(address,address)"(
      token?: string | null,
      account?: string | null
    ): PauserAddedEventFilter;
    PauserAdded(
      token?: string | null,
      account?: string | null
    ): PauserAddedEventFilter;

    "PauserRemoved(address,address)"(
      token?: string | null,
      account?: string | null
    ): PauserRemovedEventFilter;
    PauserRemoved(
      token?: string | null,
      account?: string | null
    ): PauserRemovedEventFilter;

    "Unpaused(address,address)"(
      token?: string | null,
      account?: null
    ): UnpausedEventFilter;
    Unpaused(token?: string | null, account?: null): UnpausedEventFilter;
  };

  estimateGas: {
    addAllowlistAdmin(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    addAllowlisted(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    addBlocklistAdmin(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    addBlocklisted(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    addCertificateSigner(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    addPauser(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isAllowlistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isAllowlisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isBlocklistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isBlocklisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isCertificateSigner(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isPauser(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * called by the owner to pause, triggers stopped state
     */
    pause(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     */
    paused(token: string, overrides?: CallOverrides): Promise<BigNumber>;

    removeAllowlistAdmin(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    removeAllowlisted(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    removeBlocklistAdmin(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    removeBlocklisted(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    removeCertificateSigner(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    removePauser(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    renounceAllowlistAdmin(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    renounceBlocklistAdmin(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    renounceCertificateSigner(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    renouncePauser(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * called by the owner to unpause, returns to normal state
     */
    unpause(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get the list of token controllers for a given token.
     */
    retrieveTokenSetup(
      token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Register token setup.
     */
    registerTokenSetup(
      token: string,
      certificateActivated: BigNumberish,
      allowlistActivated: boolean,
      blocklistActivated: boolean,
      granularityByPartitionActivated: boolean,
      holdsActivated: boolean,
      operators: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    canValidate(
      data: ValidateDataStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Function called by the token contract before executing a transfer.
     * @param data Extra information.
     * @param from Token holder.
     * @param operator Address which triggered the balance decrease (through transfer or redemption).
     * @param operatorData Extra information, attached by the operator (if any).
     * @param partition Name of the partition (left empty for ERC20 transfer).
     * @param payload Payload of the initial transaction.
     * @param to Token recipient for a transfer and 0x for a redemption.
     * @param value Number of tokens the token holder balance is decreased by.
     */
    tokensToValidate(
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get granularity for a given partition.
     * @param partition Name of the partition.
     * @param token Token address.
     */
    granularityByPartition(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Set partition granularity
     */
    setGranularityByPartition(
      token: string,
      partition: BytesLike,
      granularity: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Create a new token pre-hold.
     */
    preHoldFor(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Create a new token pre-hold with expiration date.
     */
    preHoldForWithExpirationDate(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Create a new token hold.
     */
    hold(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Create a new token hold with expiration date.
     */
    holdWithExpirationDate(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Create a new token hold on behalf of the token holder.
     */
    holdFrom(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Create a new token hold with expiration date on behalf of the token holder.
     */
    holdFromWithExpirationDate(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Release token hold.
     */
    releaseHold(
      token: string,
      holdId: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Renew hold.
     */
    renewHold(
      token: string,
      holdId: BytesLike,
      timeToExpiration: BigNumberish,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Renew hold with expiration time.
     */
    renewHoldWithExpirationDate(
      token: string,
      holdId: BytesLike,
      expiration: BigNumberish,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Execute hold.
     */
    executeHold(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Execute hold and keep open.
     */
    executeHoldAndKeepOpen(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Retrieve hold data.
     */
    retrieveHoldData(
      token: string,
      holdId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Total supply on hold.
     */
    totalSupplyOnHold(
      token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Total supply on hold for a specific partition.
     */
    totalSupplyOnHoldByPartition(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get balance on hold of a tokenholder.
     */
    balanceOnHold(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get balance on hold of a tokenholder for a specific partition.
     */
    balanceOnHoldByPartition(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get spendable balance of a tokenholder.
     */
    spendableBalanceOf(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get spendable balance of a tokenholder for a specific partition.
     */
    spendableBalanceOfByPartition(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get state of certificate (used or not).
     * @param sender Address whom to check the counter of.
     * @param token Token address.
     */
    usedCertificateNonce(
      token: string,
      sender: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get state of certificate (used or not).
     * @param salt First 32 bytes of certificate whose validity is being checked.
     * @param token Token address.
     */
    usedCertificateSalt(
      token: string,
      salt: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    addAllowlistAdmin(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    addAllowlisted(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    addBlocklistAdmin(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    addBlocklisted(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    addCertificateSigner(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    addPauser(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isAllowlistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isAllowlisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isBlocklistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isBlocklisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isCertificateSigner(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isPauser(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * called by the owner to pause, triggers stopped state
     */
    pause(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     */
    paused(
      token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    removeAllowlistAdmin(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    removeAllowlisted(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    removeBlocklistAdmin(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    removeBlocklisted(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    removeCertificateSigner(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    removePauser(
      token: string,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    renounceAllowlistAdmin(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    renounceBlocklistAdmin(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    renounceCertificateSigner(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    renouncePauser(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * called by the owner to unpause, returns to normal state
     */
    unpause(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the list of token controllers for a given token.
     */
    retrieveTokenSetup(
      token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Register token setup.
     */
    registerTokenSetup(
      token: string,
      certificateActivated: BigNumberish,
      allowlistActivated: boolean,
      blocklistActivated: boolean,
      granularityByPartitionActivated: boolean,
      holdsActivated: boolean,
      operators: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    canValidate(
      data: ValidateDataStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Function called by the token contract before executing a transfer.
     * @param data Extra information.
     * @param from Token holder.
     * @param operator Address which triggered the balance decrease (through transfer or redemption).
     * @param operatorData Extra information, attached by the operator (if any).
     * @param partition Name of the partition (left empty for ERC20 transfer).
     * @param payload Payload of the initial transaction.
     * @param to Token recipient for a transfer and 0x for a redemption.
     * @param value Number of tokens the token holder balance is decreased by.
     */
    tokensToValidate(
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get granularity for a given partition.
     * @param partition Name of the partition.
     * @param token Token address.
     */
    granularityByPartition(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Set partition granularity
     */
    setGranularityByPartition(
      token: string,
      partition: BytesLike,
      granularity: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Create a new token pre-hold.
     */
    preHoldFor(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Create a new token pre-hold with expiration date.
     */
    preHoldForWithExpirationDate(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Create a new token hold.
     */
    hold(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Create a new token hold with expiration date.
     */
    holdWithExpirationDate(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Create a new token hold on behalf of the token holder.
     */
    holdFrom(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Create a new token hold with expiration date on behalf of the token holder.
     */
    holdFromWithExpirationDate(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Release token hold.
     */
    releaseHold(
      token: string,
      holdId: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Renew hold.
     */
    renewHold(
      token: string,
      holdId: BytesLike,
      timeToExpiration: BigNumberish,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Renew hold with expiration time.
     */
    renewHoldWithExpirationDate(
      token: string,
      holdId: BytesLike,
      expiration: BigNumberish,
      certificate: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Execute hold.
     */
    executeHold(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Execute hold and keep open.
     */
    executeHoldAndKeepOpen(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Retrieve hold data.
     */
    retrieveHoldData(
      token: string,
      holdId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Total supply on hold.
     */
    totalSupplyOnHold(
      token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Total supply on hold for a specific partition.
     */
    totalSupplyOnHoldByPartition(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get balance on hold of a tokenholder.
     */
    balanceOnHold(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get balance on hold of a tokenholder for a specific partition.
     */
    balanceOnHoldByPartition(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get spendable balance of a tokenholder.
     */
    spendableBalanceOf(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get spendable balance of a tokenholder for a specific partition.
     */
    spendableBalanceOfByPartition(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get state of certificate (used or not).
     * @param sender Address whom to check the counter of.
     * @param token Token address.
     */
    usedCertificateNonce(
      token: string,
      sender: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get state of certificate (used or not).
     * @param salt First 32 bytes of certificate whose validity is being checked.
     * @param token Token address.
     */
    usedCertificateSalt(
      token: string,
      salt: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
